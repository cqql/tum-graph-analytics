#!/usr/bin/env python

import argparse

import numpy as np

import matrix


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-t",
                        "--tolerance",
                        type=float,
                        default=0.5,
                        help="Tolerance for correct prediction")
    parser.add_argument("-R", help="Path to rating matrix")
    parser.add_argument("-P", help="Path to P factorization")
    parser.add_argument("-U", help="Path to U^T factorization")
    parser.add_argument("--pbias", help="Path to P bias")
    parser.add_argument("--ubias", help="Path to U bias")
    parser.add_argument("--mean", help="Path to mean")

    args = parser.parse_args()
    tolerance = args.tolerance

    R = matrix.loadfile(args.R)
    P = np.loadtxt(args.P, delimiter=",", ndmin=2)
    U = np.loadtxt(args.U, delimiter=",", ndmin=2).T

    if args.mean:
        mean = np.loadtxt(args.mean, delimiter=",", ndmin=1)[0]
    else:
        mean = 0.0

    if args.pbias:
        Pbias = np.loadtxt(args.pbias, delimiter=",")
    else:
        Pbias = np.zeros((P.shape[0], 1))

    if args.ubias:
        Ubias = np.loadtxt(args.ubias, delimiter=",")
    else:
        Ubias = np.zeros((1, U.shape[1]))

    colnnz = R.getnnz(axis=0)
    rownnz = R.getnnz(axis=1)

    mse = 0
    correct = 0

    for k in range(R.nnz):
        i, j = R.row[k], R.col[k]
        expected = R.data[k]
        actual = mean + Pbias[i] + Ubias[j] + P[i, :].dot(U[:, j])
        error = abs(expected - actual)

        mse += error * error

        if error <= tolerance:
            correct += 1

    print("MSE = {}".format(mse / R.nnz))
    print("Correct {}; Incorrect {}; Recall/Accuracy {:.3f}".format(
        correct, R.nnz - correct, correct / R.nnz))


if __name__ == "__main__":
    main()
