#!/usr/bin/env python

import argparse
import math
import os

import numpy as np

import matrix


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-t",
                        "--tolerance",
                        type=float,
                        default=0.5,
                        help="Tolerance for correct prediction")
    parser.add_argument("-R", help="Path to rating matrix")
    parser.add_argument("-Q", help="Path to item factors")
    parser.add_argument("-P", help="Path to product factors")
    parser.add_argument("-Y", help="Path to implicit feedback factors")
    parser.add_argument("--bi", help="Path to item biases")
    parser.add_argument("--bu", help="Path to user biases")
    parser.add_argument("--mu", help="Path to overall mean")
    parser.add_argument(
        "-d",
        "--dir",
        help="Directory with factorizations as created by mf-als/bias-mf")

    args = parser.parse_args()
    tolerance = args.tolerance

    if args.dir:
        if args.R is None:
            args.R = os.path.join(args.dir, "test")

        args.Q = os.path.join(args.dir, "Q")
        args.P = os.path.join(args.dir, "P")
        args.Y = os.path.join(args.dir, "Y")

        if os.path.isfile(os.path.join(args.dir, "mu")):
            args.mu = os.path.join(args.dir, "mu")

        if os.path.isfile(os.path.join(args.dir, "bi")):
            args.bi = os.path.join(args.dir, "bi")

        if os.path.isfile(os.path.join(args.dir, "bu")):
            args.bu = os.path.join(args.dir, "bu")

    R = matrix.loadfile(args.R)
    Q = np.loadtxt(args.Q, delimiter=",", ndmin=2)
    P = np.loadtxt(args.P, delimiter=",", ndmin=2)
    Y = np.loadtxt(args.Y, delimiter=",", ndmin=2)

    if args.mu:
        mu = np.loadtxt(args.mu, delimiter=",", ndmin=1)[0]
    else:
        mu = 0.0

    if args.bi:
        bi = np.loadtxt(args.bi, delimiter=",")
    else:
        bi = np.zeros((P.shape[0],))

    if args.bu:
        bu = np.loadtxt(args.bu, delimiter=",")
    else:
        bu = np.zeros((U.shape[1],))

    colnnz = R.getnnz(axis=0)
    rownnz = R.getnnz(axis=1)

    mse = 0
    correct = 0

    Ru = R.getnnz(axis=0)

    for k in range(R.nnz):
        i, u = R.row[k], R.col[k]
        expected = R.data[k]
        Ys = np.sum(Y[:, R.row[R.col == u]], axis=1)
        actual = mu + bi[i] + bu[u] + Q[:, i].dot(P[:, u] + (1/math.sqrt(abs(Ru[u]))) * Ys)
        error = abs(expected - actual)

        mse += error * error

        if error <= tolerance:
            correct += 1

    print("MSE = {}".format(mse / R.nnz))
    print("Correct {}; Incorrect {}; Recall/Accuracy {:.3f}".format(
        correct, R.nnz - correct, correct / R.nnz))


if __name__ == "__main__":
    main()
