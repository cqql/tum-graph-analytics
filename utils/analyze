#!/usr/bin/env python

import argparse
import math
import os

import numpy as np

import matrix


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-t",
                        "--tolerance",
                        type=float,
                        default=0.5,
                        help="Tolerance for correct prediction")
    parser.add_argument(
        "-d",
        "--data",
        help="Directory with preprocessed data and factorizations")
    parser.add_argument("-m",
                        "--mode",
                        choices=["train", "test"],
                        default="test")

    args = parser.parse_args()
    tolerance = args.tolerance
    data = args.data
    mode = args.mode
    Rpath = os.path.join(data, mode)
    Qpath = os.path.join(data, "Q")
    Ppath = os.path.join(data, "P")
    Ypath = os.path.join(data, "Y")
    mupath = os.path.join(data, "mu")
    bipath = os.path.join(data, "bi")
    bupath = os.path.join(data, "bu")

    # Ratings matrix
    R = matrix.loadfile(Rpath)

    # Item factors
    Q = np.loadtxt(Qpath, delimiter=",", ndmin=2)

    # User factors
    P = np.loadtxt(Ppath, delimiter=",", ndmin=2)

    # Implicit feedback factors
    Y = np.loadtxt(Ypath, delimiter=",", ndmin=2)

    # Overall mean
    if os.path.isfile(mupath):
        mu = np.loadtxt(mupath, delimiter=",", ndmin=1)[0]
    else:
        mu = 0.0

    # Item biases
    if os.path.isfile(bipath):
        bi = np.loadtxt(bipath, delimiter=",")
    else:
        bi = np.zeros((Q.shape[0], ))

    # User biases
    if os.path.isfile(bupath):
        bu = np.loadtxt(bupath, delimiter=",")
    else:
        bu = np.zeros((P.shape[1], ))

    colnnz = R.getnnz(axis=0)
    rownnz = R.getnnz(axis=1)

    mse = 0
    correct = 0

    Ru = R.getnnz(axis=0)

    for k in range(R.nnz):
        i, u = R.row[k], R.col[k]
        expected = R.data[k]

        Ys = np.sum(Y[:, R.row[R.col == u]], axis=1)
        biases = mu + bi[i] + bu[u]
        interactions = Q[:, i].dot(P[:, u] + (1 / math.sqrt(abs(Ru[u]))) * Ys)
        actual = biases + interactions

        error = abs(expected - actual)
        mse += error * error

        if error <= tolerance:
            correct += 1

    print("MSE = {}".format(mse / R.nnz))
    print("Correct {}; Incorrect {}; Recall/Accuracy {:.3f}".format(
        correct, R.nnz - correct, correct / R.nnz))


if __name__ == "__main__":
    main()
